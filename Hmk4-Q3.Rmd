---
title: "EDAV Final Project"
author: "Lea Collin"
date: "November 14, 2018"
output: pdf_document
---

In this final project, my group and I will be looking at Spotify data provided by the students in EDAV. We thought it would be interesting to look at the music tastes of our class. We will specifically be looking at the playlists automatically created by Spotify last year at the end of 2017 entitled 'Your Top Songs 2017'. This is a playlist that Spotify automatically created of the 100 most played songs for each of its users in the year 2017. This seems like it will be a pretty good indicator of people's personal music tastes...or at least a look into how their 2017 was. 

For this project, we will be using the Spotify API and the R package for it, Spotifyr. Note that we are using the dev version of this package, not the CRAN version. 

```{r, include = FALSE}
library(spotifyr)
Sys.setenv(SPOTIFY_CLIENT_ID = '')
Sys.setenv(SPOTIFY_CLIENT_SECRET = '')

access_token <- get_spotify_access_token()
```

For this assignment, I will be looking at the danceability of mine and my group's "Your Top Songs 2017". I am hoping that along the way I will gain interesting insights about how this track feature is related to other variables as well as how it is distributed across my group members. 

The very first step is to load the playlist from my Spotify account and get the audio features. That is what the following code chunk accomplishes. 

```{r}
library(ggplot2)
playlists <- get_user_playlists('leac750')
my_2017 <- playlists[which(playlists$playlist_name == 'Your Top Songs 2017'),]
my_2017 <- get_playlist_audio_features('leac750', my_2017$playlist_uri)
```

Danceability is a continous variable between 0 and 1 so it seems reasonable to start with a histogram as a first visualization. Note that the below histogram will only show the danceability of songs within my playlist. I've played around a bit with the number of bins to be able to see the main patterns without getting too caught in capturing every minute detail.

```{r}
my_dance_hist <- ggplot(my_2017, aes(x = danceability)) +
  geom_histogram(color = "blue", fill = "#99CCFF", bins = 20) +
  scale_x_continuous(breaks = seq(min(0), max(1.0), by = 0.1)) +
  ylab("Frequency")
my_dance_hist
```

There are definitely two modes here, one at ~0.65 danceability and one at ~0.75. What is clear is that there are a higher number of songs that have at least 0.5 danceability or higher in my playlist (I am not surprised by this). I will also look at a density curve of this variable for my playlist simply because it was a bit hard to choose the number of bins that was appropriate and the density curve allows us to circumvent this issue. I think I will also make density curve graphs for my group members' playlists as well to more easily compare the danceability between our playlists. 

```{r}
my_dance_density <- ggplot(my_2017, aes(x = danceability,  fill = "#99CCFF")) + 
  geom_density(alpha = 1) +
  scale_x_continuous(breaks = seq(min(0), max(1), by = 0.1))
my_dance_density
```

Okay so that doesn't look great so I think I will just make a density curve graph to compare all of our playlists. The code below gets everyone else's playlists. 

```{r}
danielle <- get_playlist_audio_features('danielle219', '37i9dQZF1E9Lke9WJ01eT7')
hammaad <- get_playlist_audio_features('1256140081', '37i9dQZF1E9ECwVUJQFrgP')
kelly <- get_playlist_audio_features('22ugjl3xvvzgwtbwi3ubpt72a', '37i9dQZF1E9VRPVezelVUk')
```

```{r}
my_2017$user_id <- 'lea'
hammaad$user_id <- 'hammaad'
kelly$user_id <- 'kelly'
danielle$user_id <- 'danielle'
all <- rbind(my_2017, hammaad)
all <- rbind(all, kelly)
all <- rbind(all, danielle)
```

To compare everyone's distribution of danceability in their top 2017 songs, I will make a faceted histogram, a density curve and a boxplot graph. I'll decide later which one I think is best. 

```{r}
all$user_id <- as.factor(all$user_id)
all_danceability_density <- ggplot(all, aes(x = danceability, fill = user_id)) +
  geom_density(alpha = 0.3) +
  scale_x_continuous(breaks = seq(min(0), max(1), by = 0.1))
all_danceability_density
```

```{r}
# REORDER BY MEDIAN
all_box <- ggplot(all, aes(x = user_id, y = danceability)) +
  geom_boxplot(fill='#99CCFF', color="black")
all_box
```

```{r}
all_hist <-ggplot(all, aes(x=danceability))+
  geom_histogram(color="blue", fill="#99CCFF", bins = 20)+
  scale_x_continuous(breaks = seq(min(0), max(1), by = 0.1)) +
  facet_grid(user_id ~ .) 
all_hist
```

Quick instinct: boxplot is easiest to read in this case.

Now I want to look at the relation of danceability to other continuous variables in the dataset. Initial variables that seem interesting to look at in their relationship to danceability is: track_popularity, energy, loudness, speechiness, acousticness, liveness, valence, tempo and duration. I don't want to make a scatterplot matrix because I want to really focus on danceability so I'll use the ggarrange() function from the **ggpubr** package.

Before plotting, I'm just going to normalize every category that is not already between 0 and 1.

```{r}
x <- all$loudness
all$normalized_loudness <- (x-min(x))/(max(x)-min(x))
all$normalized_pop <- all$track_popularity/100
x <- all$tempo
all$normalized_tempo <- (x-min(x))/(max(x)-min(x))
x <- all$duration_ms
all$normalized_duration <- (x-min(x))/(max(x)-min(x))
```

```{r}
dance_loudness <- ggplot(all, aes(x = normalized_loudness, y = danceability)) + geom_point() + theme_classic()
dance_pop <- ggplot(all, aes(x = normalized_pop, y = danceability)) + geom_point() + theme_classic()
dance_speech <- ggplot(all, aes(x = speechiness, y = danceability)) + geom_point() + theme_classic()
dance_valence <- ggplot(all, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
dance_acoustic <- ggplot(all, aes(x = acousticness, y = danceability)) + geom_point() + theme_classic()
dance_live <- ggplot(all, aes(x = liveness, y = danceability)) + geom_point() + theme_classic()
dance_tempo <- ggplot(all, aes(x = normalized_tempo, y = danceability)) + geom_point() + theme_classic()
dance_energy <- ggplot(all, aes(x = energy, y = danceability)) + geom_point() + theme_classic()
dance_duration <- ggplot(all, aes(x = normalized_duration, y = danceability)) + geom_point() + theme_classic()
```

```{r, fig.height = 12, fig.width = 20}
library(ggpubr)
ggarrange(dance_valence, dance_loudness, dance_pop, dance_acoustic, dance_energy, dance_tempo, dance_live, dance_speech, dance_duration + rremove("x.text"),
          ncol = 3, nrow = 3)
```

It seems that there is no strong correlation between danceability and any of the variables explored. There is a slight positive correlation between danceability and valence. For fun, let's look at a scatterplot of valence for each person in my group.  

```{r}
lea_valence <- ggplot(my_2017, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
kelly_valence <- ggplot(kelly, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
hammaad_valence <- ggplot(hammaad, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
danielle_valence <- ggplot(danielle, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
ggarrange(lea_valence, kelly_valence, danielle_valence, hammaad_valence + rremove("x.text"),
             labels = c("Lea", "Kelly", "Danielle", "Hammaad"),
          ncol = 2, nrow = 2)
```

They actually all look fairly positively correlated so let's just look at the correlation coefficients between valence and danceability for each person. 

```{r}
cor(my_2017$valence, my_2017$danceability)
cor(kelly$valence, kelly$danceability)
cor(danielle$valence, danielle$danceability)
cor(hammaad$valence, hammaad$danceability)
```

Kelly and my song's have decent correlation between danceability and valence whereas Hammaad and Danielle's songs really don't have much. Interesting to note!