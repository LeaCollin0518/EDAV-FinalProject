---
title: "EDAV Final Project"
author: "Lea Collin"
date: "December 10, 2018"
output: pdf_document
---

In this final project, my group and I will be looking at Spotify data provided by the students in EDAV. We thought it would be interesting to look at the music tastes of our class. We will specifically be looking at the playlists automatically created by Spotify last year at the end of 2017 entitled 'Your Top Songs 2017'. This is a playlist that Spotify automatically created of the 100 most played songs for each of its users in the year 2017. This seems like it will be a pretty good indicator of people's personal music tastes...or at least a look into how their 2017 was. 

For this project, we will be using the Spotify API and the R package for it, Spotifyr. Note that we are using the dev version of this package, not the CRAN version. 

```{r, include = FALSE}
library(spotifyr)
Sys.setenv(SPOTIFY_CLIENT_ID = '')
Sys.setenv(SPOTIFY_CLIENT_SECRET = '')

access_token <- get_spotify_access_token()
```

For this assignment, I will be looking at the danceability of mine and my group's "Your Top Songs 2017". I am hoping that along the way I will gain interesting insights about how this track feature is related to other variables as well as how it is distributed across my group members. 

The very first step is to load the playlist from my Spotify account and get the audio features. That is what the following code chunk accomplishes. 

```{r}
setwd("~/Columbia/EDAV/FinalProject/EDAV-FinalProject")
library(tidyverse)
playlists <- get_user_playlists('leac750')
my_2017 <- playlists[which(playlists$playlist_name == 'Your Top Songs 2017'),]
lea <- get_playlist_audio_features('leac750', my_2017$playlist_uri)
```

Danceability is a continous variable between 0 and 1 so it seems reasonable to start with a histogram as a first visualization. Note that the below histogram will only show the danceability of songs within my playlist. I've played around a bit with the number of bins to be able to see the main patterns without getting too caught in capturing every minute detail.

```{r}
my_dance_hist <- ggplot(my_2017, aes(x = danceability)) +
  geom_histogram(color = "blue", fill = "#99CCFF", bins = 20) +
  scale_x_continuous(breaks = seq(min(0), max(1.0), by = 0.1)) +
  ylab("Frequency")
my_dance_hist
```

There are definitely two modes here, one at ~0.65 danceability and one at ~0.75. What is clear is that there are a higher number of songs that have at least 0.5 danceability or higher in my playlist (I am not surprised by this). I will also look at a density curve of this variable for my playlist simply because it was a bit hard to choose the number of bins that was appropriate and the density curve allows us to circumvent this issue. I think I will also make density curve graphs for my group members' playlists as well to more easily compare the danceability between our playlists. 

```{r}
my_dance_density <- ggplot(my_2017, aes(x = danceability,  fill = "#99CCFF")) + 
  geom_density(alpha = 1) +
  scale_x_continuous(breaks = seq(min(0), max(1), by = 0.1))
my_dance_density
```

Okay so that doesn't look great so I think I will just make a density curve graph to compare all of our playlists. The code below gets everyone else's playlists. 

```{r}
danielle <- get_playlist_audio_features('danielle219', '37i9dQZF1E9Lke9WJ01eT7')
hammaad <- get_playlist_audio_features('1256140081', '37i9dQZF1E9ECwVUJQFrgP')
kelly <- get_playlist_audio_features('22ugjl3xvvzgwtbwi3ubpt72a', '37i9dQZF1E9VRPVezelVUk')
```

```{r}
lea$user_id <- 'lea'
hammaad$user_id <- 'hammaad'
kelly$user_id <- 'kelly'
danielle$user_id <- 'danielle'
all <- rbind(my_2017, hammaad)
all <- rbind(all, kelly)
all <- rbind(all, danielle)
setwd("~/Columbia/EDAV/FinalProject/EDAV-FinalProject")
# writing group data to csv
write.csv(all, file = "GroupData.csv")
```

To compare everyone's distribution of danceability in their top 2017 songs, I will make a faceted histogram, a density curve and a boxplot graph. I'll decide later which one I think is best. 

```{r}
all$user_id <- as.factor(all$user_id)
all_danceability_density <- ggplot(all, aes(x = danceability, fill = user_id)) +
  geom_density(alpha = 0.3) +
  scale_x_continuous(breaks = seq(min(0), max(1), by = 0.1))
all_danceability_density
```

Perhaps a ridgeline plot would actually be better here. 

```{r}
library(ggridges)
all_ridges <- ggplot(all, aes(x = danceability, y = user_id)) + 
  geom_density_ridges2(scale = 2, fill = "#99CCFF") +
  theme_ridges() +
  scale_x_continuous(breaks = seq(min(0), max(1), by = 0.1)) +
  ylab("User")
all_ridges
```


```{r}
all_box <- ggplot(all, aes(x = reorder(user_id, danceability, FUN = median), y = danceability)) +
  geom_boxplot(fill='#99CCFF', color="black")
all_box
```

```{r}
all_hist <-ggplot(all, aes(x=danceability))+
  geom_histogram(color="blue", fill="#99CCFF", bins = 20)+
  scale_x_continuous(breaks = seq(min(0), max(1), by = 0.1)) +
  facet_grid(user_id ~ .) 
all_hist
```

Quick instinct: boxplot is easiest to read in this case.

Now I want to look at the relation of danceability to other continuous variables in the dataset. Initial variables that seem interesting to look at in their relationship to danceability is: track_popularity, energy, loudness, speechiness, acousticness, liveness, valence, tempo and duration. I don't want to make a scatterplot matrix because I want to really focus on danceability so I'll use the ggarrange() function from the **ggpubr** package.

Before plotting, I'm just going to normalize every category that is not already between 0 and 1.

```{r}
x <- all$loudness
all$normalized_loudness <- (x-min(x))/(max(x)-min(x))
all$normalized_pop <- all$track_popularity/100
x <- all$tempo
all$normalized_tempo <- (x-min(x))/(max(x)-min(x))
x <- all$duration_ms
all$normalized_duration <- (x-min(x))/(max(x)-min(x))
```

```{r}
dance_loudness <- ggplot(all, aes(x = normalized_loudness, y = danceability)) + geom_point() + theme_classic()
dance_pop <- ggplot(all, aes(x = normalized_pop, y = danceability)) + geom_point() + theme_classic()
dance_speech <- ggplot(all, aes(x = speechiness, y = danceability)) + geom_point() + theme_classic()
dance_valence <- ggplot(all, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
dance_acoustic <- ggplot(all, aes(x = acousticness, y = danceability)) + geom_point() + theme_classic()
dance_live <- ggplot(all, aes(x = liveness, y = danceability)) + geom_point() + theme_classic()
dance_tempo <- ggplot(all, aes(x = normalized_tempo, y = danceability)) + geom_point() + theme_classic()
dance_energy <- ggplot(all, aes(x = energy, y = danceability)) + geom_point() + theme_classic()
dance_duration <- ggplot(all, aes(x = normalized_duration, y = danceability)) + geom_point() + theme_classic()
```

```{r, fig.height = 12, fig.width = 20}
library(ggpubr)
ggarrange(dance_valence, dance_loudness, dance_pop, dance_acoustic, dance_energy, dance_tempo, dance_live, dance_speech, dance_duration + rremove("x.text"),
          ncol = 3, nrow = 3)
```

It seems that there is no strong correlation between danceability and any of the variables explored. There is a slight positive correlation between danceability and valence. For fun, let's look at a scatterplot of valence for each person in my group. NOTE: after doing a small amount of research, it seems that liveness is an estimate of the probability that the track was recorded live, so it makes sense why this would have nothing to do with danceability. 

```{r}
lea_valence <- ggplot(my_2017, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
kelly_valence <- ggplot(kelly, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
hammaad_valence <- ggplot(hammaad, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
danielle_valence <- ggplot(danielle, aes(x = valence, y = danceability)) + geom_point() + theme_classic()
ggarrange(lea_valence, kelly_valence, danielle_valence, hammaad_valence + rremove("x.text"),
             labels = c("Lea", "Kelly", "Danielle", "Hammaad"),
          ncol = 2, nrow = 2)
```

They actually all look fairly positively correlated so let's just look at the correlation coefficients between valence and danceability for each person. 

```{r}
cor(my_2017$valence, my_2017$danceability)
cor(kelly$valence, kelly$danceability)
cor(danielle$valence, danielle$danceability)
cor(hammaad$valence, hammaad$danceability)
```

Kelly and my song's have decent correlation between danceability and valence whereas Hammaad and Danielle's songs really don't have much. Interesting to note!

### Cleaning the class data

Now that we've sent out our survey and have given our classmates some time to answer, it's time to analyze it! The first step is to clean up the survey data. The most important part of this is being able to extract the Spotify user's id and their playlist id. Other cleaning that will be necessary is things like location, but these are not a main priority. 

```{r}
# reading in and changing the column names
survey_data <- read_csv("StudentResponses.csv", col_names = TRUE)
names(survey_data) <- c("Timestamp", "email", "uni", "age", "gender", "nationality", "location2017", "undergrad", "useFrequency", "username", "playlistID", "otherPlatform", "consent")
```

```{r}
library(stringr)
pattern <- '^spotify:user:(\\S*)$|^https://open\\.spotify\\.com/user/([^?]*)'
matches <- str_match(survey_data$username, pattern)
match1 <- matches[,2]
match2 <- matches[,3]

user <- c()

for (i in seq_along(match1)){
 if(!is.na(match1[i])){
   user <- c(user, match1[i])
 }
 else if(!is.na(match2[i])){
   user <- c(user, match2[i])
 }
 else{
   user <- c(user, NA)
 }
}

survey_data$cleanUser <- user

pattern2 <- '^spotify:user:[\\S]*:playlist:(\\S*)$|^https:\\/\\/open\\.spotify\\.com\\/playlist\\/(\\S*)$|^https:\\/\\/open\\.spotify\\.com\\/user\\/spotify\\/playlist\\/(\\S*)[\\?].*$'
playlist_matches <- str_match(survey_data$playlistID, pattern2)
playlist_matches1 <- playlist_matches[,2]
playlist_matches2 <- playlist_matches[,3]
playlist_matches3 <- playlist_matches[,4]

playlist_id <- c()

for (i in seq_along(playlist_matches1)){
 if(!is.na(playlist_matches1[i])){
   playlist_id <- c(playlist_id, playlist_matches1[i])
 }
 else if(!is.na(playlist_matches2[i])){
   playlist_id <- c(playlist_id, playlist_matches2[i])
 }
 else if(!is.na(playlist_matches3[i])){
   playlist_id <- c(playlist_id, playlist_matches3[i])
 }
 else{
   playlist_id <- c(playlist_id, NA)
 }
}

survey_data$cleanPlaylist <- playlist_id
```

Now that I've extracted everyone's user ID and their playlist ID, I'm going to clean up some of the other information, such as city and university.

```{r}
# cleaning up city
for (i in seq_along(survey_data$location2017)){
  if(!is.na(survey_data$location2017[i])){
    if(survey_data$location2017[i] == 'bangalore, India'){
    survey_data$location2017[i] = 'Bangalore, India'
  }
  if(survey_data$location2017[i] == 'NYC' || survey_data$location2017[i] == 'NYC, USA'){
    survey_data$location2017[i] = 'New York, USA'
  }
  if(survey_data$location2017[i] == 'Boston' || survey_data$location2017[i] == 'Boston,USA'){
    survey_data$location2017[i] = 'Boston, USA'
  }
  }
}
```

```{r}
# cleaning up undergrad
for (i in seq_along(survey_data$undergrad)){
  if(!is.na(survey_data$undergrad[i])){
    if(survey_data$undergrad[i] == 'Itam' || survey_data$undergrad[i] == 'Instituto Tecnologico Autonomo de Mexico'){
    survey_data$undergrad[i] = 'ITAM'
  }
  if(survey_data$undergrad[i] == 'Cornell'){
    survey_data$undergrad[i] = 'Cornell University'
  }
  if(survey_data$undergrad[i] == 'Vellore institute of technology' || survey_data$undergrad[i] == 'Vellore Institute of Technology, India'){
    survey_data$undergrad[i] = 'Vellore Institute of Technology'
  }
  }
}
```

```{r}
class_playlists = data.frame()

for (i in seq_along(survey_data$cleanUser)){
  if(!is.na(survey_data$cleanUser[i]) && !is.na(survey_data$cleanPlaylist)){
    # print(survey_data$cleanUser[i])
    temp <- get_playlist_audio_features(survey_data$cleanUser[i], survey_data$cleanPlaylist[i])
    temp$user_id <- survey_data$cleanUser[i]
    temp$location2017 <- survey_data$location2017[i]
    temp$nationality <- survey_data$nationality[i]
    temp$undergrad <- survey_data$undergrad[i]
    temp$age <- survey_data$age[i]
    temp$useFrequency <- survey_data$useFrequency[i]
    class_playlists <- rbind(class_playlists, temp)
  }
}

lea$undergrad <- 'McGill University'
hammaad$undergrad <- 'Yale University'
kelly$undergrad <- 'University of Rochester'
danielle$undergrad <- 'Duke University'

lea$location2017 <- 'Montreal, CA'
hammaad$location2017 <- 'Boston, USA'
kelly$location2017 <- 'New York, USA'
danielle$location2017 <- 'New York, USA'

lea$nationality <- 'France'
hammaad$nationality <- 'India'
kelly$nationality <- 'China'
danielle$nationality <- 'United States'

lea$age <- 22
hammaad$age <- 24
kelly$age <- 24
danielle$age <- 24

lea$useFrequency <- 3
hammaad$useFrequency <- 5
kelly$useFrequency <- 3
danielle$useFrequency <- 5

class_playlists <- rbind(class_playlists, lea)
class_playlists <- rbind(class_playlists, hammaad)
class_playlists <- rbind(class_playlists, kelly)
class_playlists <- rbind(class_playlists, danielle)

# writing all music data to csv
write.csv(class_playlists, file = "ClassMusicData.csv")
```